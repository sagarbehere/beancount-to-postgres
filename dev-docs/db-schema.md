# Beancount to Postgres DB Schema

## 1. Goal and Philosophy

This document specifies a relational database schema for storing data from `beancount` files in a Postgres database. The schema is designed with two primary audiences in mind:

1.  **A Human Developer:** To understand the structure of the database, the purpose of each table, and the rationale behind the design choices.
2.  **An AI Assistant:** To have a clear, unambiguous specification using which an AI assistant can generate appropriate SQL queries to answer user questions about their financial data in the database.

### Key Design Principles

*   **Normalization:** Avoids data redundancy. For example, each account and tag is stored only once in its own table. This ensures consistency and makes updates easier.
*   **Data Integrity:** Uses foreign keys, `NOT NULL` constraints, and `UNIQUE` constraints to ensure the data is clean, consistent, and reliable.
*   **Traceability:** The `source_file` and `source_line` columns in the `transactions` table allow any piece of data to be traced back to its exact origin in the source `beancount` file, which is invaluable for debugging.
*   **Analytic-Friendly:** The schema is structured to make common financial queries (e.g., "what were my total expenses in June?") simple and efficient. The inclusion of a derived `type` column in the `accounts` table is a key example of this.

## 2. Schema Overview

The schema consists of the following tables, which handle everything from core transactions to metadata and data integrity checks.

**Note:** The diagram below shows a simplified view of the most common tables and their relationships. Additional tables including `posting_metadata`, `links`, `transaction_links`, and `import_state` are described in the full schema definition (Section 4).

```
                               +-----> [ tags ]
                               |
[transactions] --< [transaction_tags]
      |
      +--< [transaction_metadata]
      |
      +--< [postings] >------------+
                                   |
[balance_assertions] >------- [ accounts ] <------- [documents]
                                   ^
                                   |
[prices] >-------------------------+
      |
      +-----> [ commodities ]

[events]
```

## 3. Core Rationale Explained

### Internal vs. External IDs

A core design principle in this schema is the use of two types of identifiers for transactions:

1.  **Internal ID (`id`):** A `SERIAL PRIMARY KEY` automatically generated by Postgres. Its only purpose is to uniquely identify a row *within the database*. It is used for all internal foreign key relationships (e.g., linking a posting to a transaction) because integer-based joins are extremely fast and efficient. This ID has no business meaning.

2.  **External ID (`external_id`):** A `TEXT` field that stores the unique identifier for a transaction that may exist in the beancount transaction data. This ID has business meaning and links the database record to the beancount "source of truth."

**The reason for this hybrid approach is to get the best of both worlds:**
*   **Performance & Simplicity:** Fast internal joins using meaningless integer keys.
*   **Traceability & Idempotency:** The `external_id` allows you to trace any record back to its source and, crucially, allows an import script to be re-run safely. The script can check if an `external_id` already exists to avoid creating duplicate transactions.

### Junction Tables vs. JSONB for Tags

For storing many-to-many relationships like transaction tags, a `JSONB` column might seem simpler. However, this schema uses dedicated `tags` and `transaction_tags` tables (a "junction table").

**The reason is Data Integrity.** With a junction table, each tag (e.g., `#travel`) is stored once in the `tags` table. This prevents spelling errors and inconsistencies (`#travel` vs. `#traavel`). For analysis, this clean data is paramount. It also makes analytical queries, like finding the most-used tags, far more efficient than parsing a `JSONB` column across thousands of rows.

### Derived Account Type

In the `accounts` table, the `type` column is **derived**. A beancount account name like `Expenses:Food:Groceries` contains hierarchical information. The `type` is the highest level of this hierarchy (`Expenses`).

This is derived during the import process by splitting the account name by the first colon (`:`).

**The reason is Query Performance and Simplicity.** Storing the type explicitly allows for very fast and simple high-level queries. To get total expenses, you can query `WHERE type = 'Expenses'` instead of relying on a slower `WHERE name LIKE 'Expenses:%'` pattern. This gives an LLM assistant clear, high-level categories to work with.

## 4. Full Schema Definition

### `commodities` Table
Stores all declared currencies and stock symbols. This acts as a central registry for all financial instruments.

```sql
-- A table to store all unique commodities (currencies, stocks, etc.).
-- This ensures that all transactions use recognized financial instruments.
CREATE TABLE commodities (
    id SERIAL PRIMARY KEY,
    name VARCHAR(50) NOT NULL UNIQUE, -- E.g., 'USD', 'VTSAX', 'BTC'
    -- Metadata from the 'commodity' directive, stored as JSON.
    metadata JSONB,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);
```
**Column Rationale:**
*   `name`: The symbol for the commodity (e.g., "USD").
*   `metadata`: A `JSONB` field to hold any key-value metadata associated with the commodity directive in beancount.

---
### `accounts` Table
Stores all unique accounts. Normalizing accounts is key to efficient querying.

```sql
-- A table to store all unique accounts.
CREATE TABLE accounts (
    id SERIAL PRIMARY KEY,
    name TEXT NOT NULL UNIQUE,
    -- E.g., 'Assets', 'Liabilities', 'Equity', 'Income', 'Expenses'
    type VARCHAR(50) NOT NULL,
    -- Status derived from 'open' and 'close' directives.
    status VARCHAR(20) NOT NULL DEFAULT 'open',
    open_date DATE,
    close_date DATE,
    -- Metadata from the 'open' directive, stored as JSON.
    metadata JSONB,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);
```
**Column Rationale:**
*   `name`: The full, unique beancount account name (e.g., `Assets:US:Schwab:Checking`).
*   `type`: The derived account type (e.g., `Assets`).
*   `status`, `open_date`, `close_date`: Populated from `open` and `close` directives.
*   `metadata`: A `JSONB` field for any key-value data on the `open` directive.

---
### `transactions` Table
The core table for all transaction events.

```sql
-- The core table for all transactions. Each entry represents a single transaction event.
CREATE TABLE transactions (
    id SERIAL PRIMARY KEY,
    external_id TEXT NOT NULL UNIQUE,
    date DATE NOT NULL,
    flag VARCHAR(20) NOT NULL, -- The transaction flag, e.g., '*' (cleared) or '!' (pending).
    payee TEXT,
    narration TEXT NOT NULL,
    source_file TEXT,
    source_line INTEGER,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);
```
**Column Rationale:**
*   `id`: The internal primary key for database relationships.
*   `external_id`: The unique identifier from the source system (e.g., OFX FITID). Used for idempotency and traceability.
*   `date`, `flag`, `payee`, `narration`: Directly from the beancount transaction line.
*   `source_file`, `source_line`: The file and line number where the transaction was defined. Essential for traceability.

---
### `postings` Table
Stores the individual legs of each transaction, representing the actual movement of money.

```sql
-- Each transaction is composed of two or more postings.
CREATE TABLE postings (
    id SERIAL PRIMARY KEY,
    transaction_id INTEGER NOT NULL REFERENCES transactions(id) ON DELETE CASCADE,
    flag VARCHAR(20),
    account_id INTEGER NOT NULL REFERENCES accounts(id),
    amount NUMERIC(19, 4) NOT NULL,
    currency_id INTEGER NOT NULL REFERENCES commodities(id),
    -- Beancount's cost basis ({...}) for investments.
    cost_amount NUMERIC(19, 4),
    cost_currency_id INTEGER REFERENCES commodities(id),
    -- Beancount's price (@ or @@) for currency conversions.
    price_amount NUMERIC(19, 4),
    price_currency_id INTEGER REFERENCES commodities(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);
```
**Column Rationale:**
*   `transaction_id`, `account_id`: Foreign keys linking to the parent transaction and the relevant account.
*   `flag`: Optional posting-level flag (can be different from transaction flag).
*   `amount`, `currency_id`: The value of the posting. `NUMERIC` is used to prevent floating-point errors.
*   `cost_*`, `price_*`: Fields to store beancount's detailed cost and price information, essential for investment tracking.

---
### `tags` and `transaction_tags` Tables
Manages the many-to-many relationship between transactions and tags.

```sql
-- A table to store all unique tags.
CREATE TABLE tags (
    id SERIAL PRIMARY KEY,
    name TEXT NOT NULL UNIQUE
);

-- A junction table to link transactions and tags.
CREATE TABLE transaction_tags (
    transaction_id INTEGER NOT NULL REFERENCES transactions(id) ON DELETE CASCADE,
    tag_id INTEGER NOT NULL REFERENCES tags(id) ON DELETE CASCADE,
    PRIMARY KEY (transaction_id, tag_id)
);
```
**Rationale:**
*   `tags.name`: Stores the unique tag name (e.g., `#vacation`).
*   `transaction_tags`: Links a `transaction_id` to a `tag_id`.

---
### `transaction_metadata` Table
Stores the key-value metadata associated with each transaction.

```sql
-- A table to store the key-value metadata associated with each transaction.
CREATE TABLE transaction_metadata (
    id SERIAL PRIMARY KEY,
    transaction_id INTEGER NOT NULL REFERENCES transactions(id) ON DELETE CASCADE,
    key TEXT NOT NULL,
    value TEXT NOT NULL,
    UNIQUE (transaction_id, key)
);
```
**Rationale:**
*   Captures any `key: "value"` pairs found under a transaction.

---
### `posting_metadata` Table
Stores the key-value metadata associated with each posting.

```sql
-- Stores the key-value metadata associated with each individual posting.
CREATE TABLE posting_metadata (
    id SERIAL PRIMARY KEY,
    posting_id INTEGER NOT NULL REFERENCES postings(id) ON DELETE CASCADE,
    key TEXT NOT NULL,
    value TEXT NOT NULL,
    UNIQUE (posting_id, key)
);
```
**Rationale:**
*   Captures any `key: "value"` pairs found under individual postings.

---
### `links` and `transaction_links` Tables
Manages the many-to-many relationship between transactions and links.

```sql
-- A table to store all unique links.
CREATE TABLE links (
    id SERIAL PRIMARY KEY,
    name TEXT NOT NULL UNIQUE
);

-- A junction table to link transactions and links.
CREATE TABLE transaction_links (
    transaction_id INTEGER NOT NULL REFERENCES transactions(id) ON DELETE CASCADE,
    link_id INTEGER NOT NULL REFERENCES links(id) ON DELETE CASCADE,
    PRIMARY KEY (transaction_id, link_id)
);
```
**Rationale:**
*   `links.name`: Stores the unique link name (e.g., `^invoice-123`).
*   `transaction_links`: Links a `transaction_id` to a `link_id`.

---
### `balance_assertions` Table
Stores `balance` directives for data validation.

```sql
-- Stores Beancount 'balance' assertions for data integrity checks.
CREATE TABLE balance_assertions (
    id SERIAL PRIMARY KEY,
    date DATE NOT NULL,
    account_id INTEGER NOT NULL REFERENCES accounts(id) ON DELETE CASCADE,
    amount NUMERIC(19, 4) NOT NULL,
    currency_id INTEGER NOT NULL REFERENCES commodities(id),
    source_file TEXT,
    source_line INTEGER
);
```
**Rationale:**
*   Storing balance checks allows a verification process to be run against the database to ensure the imported data is correct.

---
### `prices` Table
Stores `price` directives to track historical market values of commodities.

```sql
-- Stores historical price data for commodities from 'price' directives.
CREATE TABLE prices (
    id SERIAL PRIMARY KEY,
    date DATE NOT NULL,
    commodity_id INTEGER NOT NULL REFERENCES commodities(id) ON DELETE CASCADE,
    price_amount NUMERIC(19, 4) NOT NULL,
    price_currency_id INTEGER NOT NULL REFERENCES commodities(id),
    source_file TEXT,
    source_line INTEGER
);
```
**Rationale:**
*   Essential for tracking portfolio value over time.

---
### `events` Table
Stores `event` directives.

```sql
-- Stores 'event' directives, which associate a date with a key-value pair.
CREATE TABLE events (
    id SERIAL PRIMARY KEY,
    date DATE NOT NULL,
    name TEXT NOT NULL,
    value TEXT NOT NULL,
    source_file TEXT,
    source_line INTEGER
);
```

---
### `documents` Table
Stores `document` directives, linking accounts to external files.

```sql
-- Stores 'document' directives, linking an account to an external file path.
CREATE TABLE documents (
    id SERIAL PRIMARY KEY,
    date DATE NOT NULL,
    account_id INTEGER NOT NULL REFERENCES accounts(id) ON DELETE CASCADE,
    file_path TEXT NOT NULL,
    source_file TEXT,
    source_line INTEGER
);
```

---
### `import_state` Table
Stores the state hash of the last successful import to detect changes.

```sql
-- Stores the state hash of the last successful import to detect changes.
CREATE TABLE import_state (
    id INT PRIMARY KEY,
    last_successful_hash TEXT NOT NULL,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);
```
**Rationale:**
*   Used for the `--check` mode to determine if database is in sync with source files.

## 5. Indexing Strategy

Indexes are crucial for query performance. The following indexes should be created.

```sql
-- Indexes for faster querying on commonly searched columns.
CREATE INDEX idx_transactions_external_id ON transactions(external_id);
CREATE INDEX idx_transactions_date ON transactions(date);
CREATE INDEX idx_postings_account_id ON postings(account_id);
CREATE INDEX idx_accounts_name ON accounts(name);
CREATE INDEX idx_accounts_type ON accounts(type);
CREATE INDEX idx_tags_name ON tags(name);
CREATE INDEX idx_links_name ON links(name);
CREATE INDEX idx_transaction_metadata_key ON transaction_metadata(key);
CREATE INDEX idx_posting_metadata_key ON posting_metadata(key);
CREATE INDEX idx_balance_assertions_account_id ON balance_assertions(account_id);
CREATE INDEX idx_prices_commodity_id ON prices(commodity_id);
CREATE INDEX idx_documents_account_id ON documents(account_id);
```
